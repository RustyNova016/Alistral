use chrono::Duration;
use futures::stream;
use futures::StreamExt;
use itertools::Itertools;

use crate::datastructures::radio::collector::RadioCollector;
use crate::datastructures::radio::filters::booleans::and_filter;
use crate::datastructures::radio::filters::cooldown::cooldown_filter;
use crate::datastructures::radio::filters::min_listens::min_listen_filter;
use crate::datastructures::radio::filters::timeouts::timeout_filter;
use crate::datastructures::radio::seeders::listens::ListenSeeder;
use crate::datastructures::radio::sorters::shared::shared_listens_sorter;
use crate::models::data_storage::DataStorage;
use crate::models::playlist_stub::PlaylistStub;
use crate::utils::data_file::DataFile as _;
use crate::utils::println_cli;

pub async fn shared_radio(
    conn: &mut sqlx::SqliteConnection,
    seeder: ListenSeeder,
    other_user: String,
    min_listens: Option<u64>,
    cooldown: u64,
    collector: RadioCollector,
    token: &str,
) -> color_eyre::Result<()> {
    let username = seeder.username().clone();

    println_cli("[Seeding] Getting listens");

    // Get the seeder
    let mut other_seeder = seeder.clone();
    let recordings = seeder.seed(conn).await.expect("Couldn't find seed listens");
    other_seeder.username = other_user.clone();
    let other_recordings = other_seeder
        .seed(conn)
        .await
        .expect("Couldn't find seed listens");
    let other_recordings = other_recordings.into_iter().collect_vec();

    println_cli("[Filter] Filtering minimum listen count");
    let recordings = min_listen_filter(recordings.into_stream(), min_listens.unwrap_or(3));

    println_cli("[Filter] Filtering listen cooldown");
    let recordings = cooldown_filter(recordings, Duration::hours(cooldown as i64));

    println_cli("[Filter] Filtering listen timeouts");
    let recordings = timeout_filter(recordings);

    println_cli("[Filter] Filtering by other user");
    let recordings = and_filter(recordings, other_recordings.clone());

    println_cli("[Sorting] Calculating scores");
    let recordings = shared_listens_sorter(recordings, other_recordings).await;

    println_cli("[Finalising] Creating radio playlist");
    let collected = collector
        .collect(stream::iter(recordings).map(|r| r.recording().clone()))
        .await;

    println_cli("[Sending] Sending radio playlist to listenbrainz");
    let counter = DataStorage::load().expect("Couldn't load data storage");
    PlaylistStub::new(
        format!(
            "Radio: Shared listens #{}",
            counter.write().unwrap().incr_playlist_count()
        ),
        Some(username.to_string()),
        true,
        collected.into_iter().map(|r| r.mbid).collect(),
        Some(format!(
            "
        A radio made from the listened recordings of {username} and {other_user}</br>

        Automatically generated by: https://github.com/RustyNova016/Alistral"
        )),
    )
    .send(token)
    .await?;

    Ok(())
}
