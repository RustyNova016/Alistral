use core::pin::Pin;

use alistral_core::datastructures::entity_with_listens::recording::RecordingWithListens;
use chrono::Duration;
use futures::{stream, StreamExt};
use interzic::models::playlist_stub::PlaylistStub;
use tracing::info;

use crate::datastructures::radio::collector::RadioCollector;
use crate::datastructures::radio::filters::cooldown::cooldown_filter;
use crate::datastructures::radio::filters::min_listens::min_listen_filter;
use crate::datastructures::radio::filters::timeouts::timeout_filter;
use crate::datastructures::radio::seeders::listens::ListenSeeder;
use crate::datastructures::radio::sorters::overdue::overdue_factor_sorter;
use crate::datastructures::radio::sorters::overdue::overdue_factor_sorter_cumulative;
use crate::datastructures::radio::sorters::overdue::overdue_sorter;
use crate::models::cli::radio::RadioExportTarget;
use crate::models::data_storage::DataStorage;
use crate::models::error::ResultTEExt;
use crate::tools::radio::convert_recordings;
use crate::utils::data_file::DataFile;

//TODO: Refactor Radios params into structs
#[expect(clippy::too_many_arguments)]
pub async fn overdue_radio(
    conn: &mut sqlx::SqliteConnection,
    seeder: ListenSeeder,
    token: &str,
    min_listens: Option<u64>,
    cooldown: u64,
    overdue_factor: bool,
    collector: RadioCollector,
    at_listening_time: bool,
    target: RadioExportTarget,
) -> Result<(), crate::Error> {
    let username = seeder.username().clone();

    info!("[Seeding] Getting listens");
    let recordings = seeder.seed(conn).await.expect("Couldn't find seed listens");

    info!("[Filter] Filtering minimum listen count");
    let recordings = min_listen_filter(recordings.into_stream(), min_listens.unwrap_or(3));

    info!("[Filter] Filtering listen cooldown");
    let recordings = cooldown_filter(recordings, Duration::hours(cooldown as i64));

    info!("[Filter] Filtering listen timeouts");
    let recordings = timeout_filter(recordings);

    let recordings = if !overdue_factor {
        info!("[Sorting] Sorting listen by overdue duration");
        Box::pin(stream::iter(overdue_sorter(recordings.collect().await)))
            as Pin<Box<dyn futures::Stream<Item = RecordingWithListens>>>
    } else if !at_listening_time {
        info!("[Sorting] Sorting listen by overdue factor");
        Box::pin(stream::iter(overdue_factor_sorter(
            recordings.collect().await,
        ))) as Pin<Box<dyn futures::Stream<Item = RecordingWithListens>>>
    } else {
        info!("[Sorting] Sorting listen by overdue factor at listen time");
        Box::pin(overdue_factor_sorter_cumulative(recordings.collect().await))
    };

    info!("[Finalising] Creating radio playlist");
    let collected = collector
        .collect(recordings.map(|r| r.recording().clone()))
        .await;

    info!("[Sending] Sending radio playlist to listenbrainz");

    let counter = DataStorage::load().expect_fatal("Couldn't load data storage");
    let playlist = PlaylistStub {
        title: format!(
            "Radio: Overdue listens #{}",
            counter.write().unwrap().incr_playlist_count()
        ),
        description: "Automatically generated by: https://github.com/RustyNova016/Alistral"
            .to_string(),
        recordings: convert_recordings(conn, collected)
            .await
            .expect_fatal("Couldn't convert recordings for playlist"),
    };

    target
        .export(playlist, Some(username), Some(token))
        .await
        .expect_fatal("Couldn't send the playlist");

    Ok(())
}

// #[tokio::test]
// #[serial_test::serial]
// async fn overdue_by() {
//     use crate::datastructures::radio::collector::RadioCollectorBuilder;
//     overdue_radio(
//         "RustyNova",
//         "t",
//         None,
//         0,
//         false,
//         RadioCollectorBuilder::default()
//             .count_default()
//             .duration_default()
//             .build(),
//             true
//     )
//     .await
//     .unwrap();
// }
